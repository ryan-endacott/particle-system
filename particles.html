<!DOCTYPE html>
<html>

<head>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
    <script>



// Variables to mess with in runParticleSystem() because they require DOM
var Game = {};
var canvas;
var numParticlesLabel;
var FPSLabel;
var ctx;
var width;
var height;


// Variables for whole game
var particles = [];
var obstacles = [];
var NUMSTARTPARTICLES = 100;
var NUMEMIT = 40;
var graviton;
var gravitons = [];
var GRAVITONSTRENGTH = .9;
var particleHandler;
var obstaclePositions;
var mouseX;
var mouseY;
var leftMouseDown = false;
var rightMouseDown = false;
var count = 0;
var MAXAGE = 1000;
var MAXVEL = 7;

Game.fps = 30;

Game.run = function () {
    Game.update();
    Game.draw();
};

Game.start = function () {

    // True if unoccupied.  False if occupied. 
    // Because 2darray[inbounds][outofbounds] returns false
    obstaclePositions = get2DArray(width, height, true);

    graviton = new Graviton(0, 0, GRAVITONSTRENGTH);
    particleHandler = new ParticleHandler();

    for (var i = 0; i < NUMSTARTPARTICLES; i++) {

        var posX = getRandomInt(0, width);
        var posY = getRandomInt(0, height);
        var velX = getRandomInt(-MAXVEL, MAXVEL);
        var velY = getRandomInt(-MAXVEL, MAXVEL);

        var particle = new Particle(posX, posY, velX, velY, MAXVEL);
        particles[i] = particle;
    }

    setInterval(Game.run, 1000 / Game.fps);

    // Measure FPS
    var oldCount = count;
    setInterval(function () {
        FPSLabel.innerHTML = count - oldCount;
        oldCount = count;
    }, 1000);

}

Game.update = function () {

    count++;

    numParticlesLabel.innerHTML = particles.length;

    if (rightMouseDown) 
        emitParticles(mouseX, mouseY, NUMEMIT, MAXVEL);


    if (count % 5) {

        if (leftMouseDown) {
            graviton.posX = mouseX;
            graviton.posY = mouseY;
            graviton.attract(particles);
        }
        else if (gravitons.length > 0) {
            for (var i = 0; i < gravitons.length; i++) 
                gravitons[i].attract(particles);
        }
        else
            slowParticles(particles, .98);
    } 


    handleCollisions(particles, obstaclePositions);

    particleHandler.update(particles);


};

Game.draw = function () {
    ctx.clearRect(0, 0, width, height);

    ctx.fillStyle = 'black';

    // Black background
    ctx.fillRect(0, 0, width, height);

    ctx.fillStyle = 'red';

    particleHandler.draw(particles);


    ctx.fillStyle = 'gray';

    obstacles.forEach(function (obstacle) {
        obstacle.draw(ctx);
    });

};

// Particle wrapper to do updating and drawing to (hopefully) increase
// performance and limit function calls
function ParticleHandler() {
    this.update = function(particles) {

        var deadParticles = [];

        for (var i = 0; i < particles.length; i++) {
            var particle = particles[i];
            particle.posX += particle.velX;
            particle.posY += particle.velY;

            // Slow moving particles die faster
            var avgVel = (Math.abs(particle.velX) + Math.abs(particle.velY)) / 2;
            particle.age += 1.5 / avgVel;
            particle.age += .3;

            // Remove if older than max
            if (particle.age > MAXAGE)
                deadParticles.push(i);
        }

        for (var i = deadParticles.length - 1; i >= 0; i--)
            particles.splice(i, 1);

    };

    this.draw = function(particles) {


        ctx.beginPath();
        for (var i = 0; i < particles.length; i++) {
            var particle = particles[i];

            // Round to integers to increase performance
            var roundedX = (.5 + particle.posX) << 0;
            var roundedY = (.5 + particle.posY) << 0;

            ctx.moveTo(roundedX, roundedY);

            ctx.rect(roundedX, roundedY, 1, 1);
        }
        ctx.fill();
    };

}

// Constructor for particle object
function Particle(posX, posY, velX, velY, MAXVEL) {
    this.age = 0;
    this.posX = posX;
    this.posY = posY;

    this.setVelX = function (vel) {
        if (vel > MAXVEL) this.velX = MAXVEL;
        else if (vel < -MAXVEL) this.velX = -MAXVEL;
        else this.velX = vel;
    };

    this.setVelY = function (vel) {
        if (vel > MAXVEL) this.velY = MAXVEL;
        else if (vel < -MAXVEL) this.velY = -MAXVEL;
        else this.velY = vel;
    };

    this.setVelX(velX);
    this.setVelY(velY);
}


// Constructor for block object
function Block(posX, posY, width, height, canvasWidth, canvasHeight) {
    this.posX = posX;
    this.posY = posY;
    this.posX2 = posX + width;
    this.posY2 = posY + height;
    this.width = width;
    this.height = height;

    // Modify the obstaclePositions that holds all pixels and whether obstructed
    for (var i = Math.max(this.posX, 0); i <= Math.min(this.posX2, canvasWidth - 1); i++) {
        for (var j = Math.max(this.posY, 0); j <= Math.min(this.posY2, canvasHeight - 1); j++) {
            obstaclePositions[i][j] = false;
        }
    }

    this.draw = function (ctx) {
        ctx.fillRect(this.posX, this.posY, this.width, this.height);
    };
}

// Constructor for a graviton
function Graviton(posX, posY, strength) {
    this.strength = strength;
    this.posX = posX;
    this.posY = posY;

    this.attract = function (entities) {

        for (var i = 0; i < entities.length; i++) {
            var entity = entities[i];

            var distX = this.posX - entity.posX;
            var distY = this.posY - entity.posY;

            var invSqrt = InvSqrt(distX * distX + distY * distY);


            var newVelX = entity.velX + this.strength * invSqrt * distX;
            var newVelY = entity.velY + this.strength * invSqrt * distY;

            newVelX *= getRandomDecimal(.8, 1.2);
            newVelY *= getRandomDecimal(.8, 1.2);

            entity.setVelX(newVelX);
            entity.setVelY(newVelY);
        }
    };
}



function handleCollisions(particles, obstaclePositions) {
    for (var i = 0; i < particles.length; i++) {

        var particle = particles[i];

        // Round to integers to increase performance
        var roundedX = (.5 + particle.posX) << 0;
        var roundedY = (.5 + particle.posY) << 0;
        var roundedX2 = (.5 + particle.posX + particle.velX) << 0;
        var roundedY2 = (.5 + particle.posY + particle.velY) << 0;



        // If is going to collide after x-direction move next turn
        if (!obstaclePositions[roundedX2] || !obstaclePositions[roundedX2][roundedY]) {
            // Reverse and deplete x velocity
            particle.velX = -particle.velX * .2;
        }

        // If is going to collide after y-direction move next turn
        if (!obstaclePositions[roundedX] || !obstaclePositions[roundedX][roundedY2]) {
            // Reverse and deplete y velocity
            particle.velY = -particle.velY * .2;
        }

    }

}


function emitParticles(posX, posY, num, MAXVEL) {
    for (var i = 0; i < num; i++) {

        var velX = getRandomDecimal(-MAXVEL, MAXVEL);
        var velY = getRandomDecimal(-MAXVEL, MAXVEL);
        var p = new Particle(posX, posY, velX, velY, MAXVEL);
        particles.push(p);

    }
}

function slowParticles(particles, factor) {

    for (var i = 0; i < particles.length; i++) {

        var particle = particles[i];
        particle.velX *= factor;
        particle.velY *= factor;
    }

}


// Magical inverse square root hack from Quake 3.
// Slightly faster, why not add it?
// Source: http://jsperf.com/inverse-square-root/5
var y = new Float32Array(1);
var i = new Int32Array(y.buffer);

function InvSqrt(number) {
   var x2 = number * 0.5;
   y[0] = number;
   var threehalfs = 1.5;
  
   i[0] = 0x5f3759df - (i[0] >> 1);
  
   var number2 = y[0];
  
   return number2 * (threehalfs - (x2 * number2 * number2));
}


/**
 * Returns a random number between min and max
 */
function getRandomDecimal(min, max) {
    return Math.random() * (max - min) + min;
}

/**
 * Returns a random integer between min and max
 * Using Math.round() will give you a non-uniform distribution!
 */
function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

// Gets a 2d array filled with default value
function get2DArray(x, y, defaultValue) {

    x = x > 0 ? x : 0;
    var arr = [];

    while(x--) {
        var innerArr = []
        for (var i = 0; i < y; i++)
            innerArr.push(defaultValue);
        arr.push(innerArr);
    }

    return arr;
}


function getMousePos(canvas, evt) {
    var rect = canvas.getBoundingClientRect();
    return {
        x: evt.clientX - rect.left,
        y: evt.clientY - rect.top
    };
}





function runParticleSystem() {

    canvas = document.getElementById('particlesystem')
    numParticlesLabel = document.getElementById('numParticlesLabel');
    FPSLabel = document.getElementById('FPSLabel');

    if (canvas.getContext) {
        console.log("Starting particle system...");
        ctx = canvas.getContext('2d');
        width = canvas.width;
        height = canvas.height;

        // Event handlers to provide updated mouse stuff
        // Required DOM
        canvas.addEventListener('mousemove', function (evt) {
            var mousePos = getMousePos(canvas, evt);
            mouseX = mousePos.x;
            mouseY = mousePos.y;
        }, false);


        $(canvas).mousedown(function (evt) {
            var which = evt.which;
            if (which == 1) leftMouseDown = true;
            else if (which == 3) rightMouseDown = true;
        });

        $(canvas).mouseup(function (evt) {
            var which = evt.which;
            if (which == 1) leftMouseDown = false;
            else if (which == 3) rightMouseDown = false;
        });

        $(document).keypress(function (evt) {
            if (evt.which == 49) { // Pressed 1, so create new block
                var size = 70;
                var block = new Block(mouseX - size / 2, mouseY - size / 2, size, size, width, height);
                obstacles.push(block);
            }
            if (evt.which == 50) { // 2, so create graviton at mouse
                var grav = new Graviton(mouseX, mouseY, GRAVITONSTRENGTH);
                gravitons.push(grav);
            }
        });

        window.oncontextmenu = function () {
            return false; // cancel context menu
        }

        // Start the darn thing!
        Game.start();

    }
    else {
        canvas.innerHTML = "Sorry, the particle system will not work with your browser.";
    }
    
}


        </script>

        <style>
        /* Make everything unselectable to fix weird glitch when drag on canvas
         * highlights stuff 
         */
        .unselectable {
            -moz-user-select: none;
            -khtml-user-select: none;
            -webkit-user-select: none;
            user-select: none;
        }

        #container {
            width: 1200px;
        }

        #sidebar {
            float: right;
            width: 300px; /*container.width - canvas.width*/
        }

        #particlesystem {
            float: left;
            width: 800px;
            height: 600px;
            border: solid 1px black;
        }
        </style>

    </head>

    <body class="unselectable" onload="runParticleSystem()">
        <div id="container">
            <div id="sidebar">
                <div id="info">
                    <h1>Particle System by Ryan Endacott</h1>
                    <p>Number of particles: <label id="numParticlesLabel">0</label></p>
                    <p>FPS: <label id="FPSLabel">30</label>
                </div>
                <div id="instructions">
                    <ul>
                        <li>Hold left click to create a graviton at the mouse.</li>
                        <li>Hold right click to emit new particles.</li>
                        <li>Press 1 to create an obstacle.</li>
                        <li>Press 2 to create a permanent graviton at the mouse.  Note:  Your graviton will turn off all others.</li>
                    </ul>
                </div>
            </div>
          <canvas id="particlesystem" width="800px" height="600px"></canvas>
        </div>
      </body>

      </html>